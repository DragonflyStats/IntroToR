
 
Introduction to R
History of R

\subsection{The R Programming Language}
R is a flexible language that is object oriented and thus allows the manipulation of a complex
data structures in a condensed and efficient manner.
 
R's graphical abilities are also remarkable with possible interfacing with text processors such as
Latex with the package sweave.
R offers the addtional advantage of being a free and opensource system under the GNU general
public licence.

R is primarily a statistical language.
R can be installed free of charge from www.r-project.org

An online guide "An Introduction to R" can be access by typing
help.start() at the command prompt to access this.

\subsubsection{Defining variables}
R is case sensitive.
A convention is to use define a variable name with a capital letter.
This reduces the chance of overwriting inbuild R functions, which are usually written in lowercase letters.


Functions in R can be treated as "objects" that can be manipulated or used recursively.

R shares many aspects with both Object orietnated and Functional programming langguages.
all data in R is stored an objects, which have a range of "\texttt{methods}" available.
The "class" of an object can be found using the class() function.
Using the Help functions
Embedded help commands "help()" and "help.search()" are good starting points to gather information. 
Note that "help.search()" opens a web browser linked to the local manual pages.
 
 
%--------------------------------------------------------------------------------------------------------------------------------------%
Probability distributions
The discrete uniform distribution
parameters: min , max.
The default values are 0 and 1.
 

Numerical methods
Matrrix “Mat2” is a positive definite symmetric matrix.
Dvls = diag(Mat1)		# extract vector of the diagonal elements of 'Mat1'
Dvls				#print to screen
as.matrix(Dvls)			# display the vector in matrix form (3R1C)
t(as.matrix(Dvls)		# transpose of above	(1R3C)
Idty = diag(c(1,1,1))		# create the identity matrix
Idty				#print to screen
Dgnl = diag(diag(Mat1))	# create a 'D' matrix 	(courework: diagonalization)
Dgnl				
Dvls * Idty			# alternative method with scalar multiplication.
				# N.B.  Dvls is a vector, not a matrix.
Dgnl.inv = solve(Dgnl)		# invert the D matrix
Dgnl.inv		
Rmdr = Mat1 - Dgnl		# Compute the "Remainder" matrix (elementwise subtraction)
# construct a positive definite symmetric three-by-three matrix
Mat2 = matrix(c(1,3,1,3,13,7,1,7,6),ncol=3)
chol(Mat2)			#Cholesky decomposition of Matrix A
More on Matrices
Note that the following commands are useful for Experimental Design.
rowMeans(Mat1) 			#Returns vector of row means. 
rowSums(Mat1) 			#Returns vector of row sums.  
colMeans(Mat1) 			#Returns vector of column means.  
colSums(Mat1) 				#Returns vector of coumn means.  
If x and y are matrices then the covariances (or correlations) between the columns of x and the columns of y are computed.


var( Mat1[,1] )			# determine the variance of the first column 
var ( Mat1[,2] )			# determine the variance of the second column
var ( Mat1[3,] )			# determine the variance of the third row
cov ( Mat1[,1], Mat1[,2] )	# covariance of the first two columsn
var ( Mat1)			# variance covariance matrix of all columns
VCmat=var( Mat1)		# Save as matrix “VCmat”
cor ( Mat1)			# correlation matrix of all columns
cov2cor( VCmat)		#convert a VC matrix to a correlation matrix

 
Descriptive Statistics and Basic Graphical Methods
Measures of Centrality and Dispersion
# Anscombe’s  Quartet
X1 = c(
Y1 =
 

Anscombe’s Quartet 
The uniform distribution

\subsection{Simulating a dice experiment}
Dice = runif(50,min=0,max=6)	
Dice				#print the outcomes to screen
floor(Dice)			#using the floor function
ceiling(Dice)			# using the ceiling function
Dice=ceiling(Dice)		#discretize the outcomes.
mean(Dice)			# compute the mean of the outcomes (expected value).
sd(Dice)			#compute the standard deviation of the outcomes.
# More compact alternative, using the floor function. Note the changed parameters.
Dice2=floor(runif(50,min=1,max=7))	

Questions
The expected value of a dice throw is 3.5. Is the sample mean close to this value?

The "apply" family of functions
 The Apply family of functions are 


 
Iteration Loops
Central Limit Theorem
Recall the Dice experiment in week 8.

N=100				#number of loops
Avgs=numeric(N)		#array “Avgs” store the sample means
for( i in 1:N)
	{	Dice=floor(runif(50,min=1,max=7));	Avgs[i]=mean(Dice);
	}
Avgs				#print Avgs dataset to screen

The Central limit theorem states that.
The “Dice” distribution is a discrete uniform distribution. However 
mean(Avgs)			#compute the mean. Is it roughly what we are expecting?
qqnorm(Avgs)			#draws a QQ plot that is used to check for normality.
qqline(Avgs)			#adds trend line to QQplot.
shapiro.test(Avgs)		#Shapiro Wilk test. Normality is assumed if p-value > 0.05.
			
 
